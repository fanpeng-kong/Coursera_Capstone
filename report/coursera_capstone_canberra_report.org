#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:nil arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: The Battle of the Suburbs in Canberra
#+subtitle: Applied Data Science Capstone by IBM/Coursera
#+date: <2021-06-26 Sat>
#+author: Fanpeng Kong
#+email: fanpeng@fanpengkong.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 27.1 (Org mode 9.4.6)

#+latex_class: article
#+latex_class_options:
#+latex_header:
#+latex_header_extra:
#+description:
#+keywords:
#+subtitle:
#+latex_compiler: lualatex

#+PROPERTY: header-args :eval never-export

* Introduction: Business Problem
  :PROPERTIES:
  :CUSTOM_ID: introduction-business-problem-
  :END:

Canberra, the capital city of Australia, is often known as "The Bush
Capital" to Aussies (and yes, we put that on our vehicle number plates).
It is nothing like the usual metropolis like Madrid or Beijing which you
would expect from other countries. It is an entirely planned garden-like
city and in recent years, Canberra has been ranked among the world's
best cities to live. As per 2021, there are about 430 thousands
residents living accross the 814 square kilometeres region and the
poupulation density of Canberra is only about 528/km2. This figure is
not only low compared to other capital cities around the world but also
only ranks 6 among all the 8 Australia capitals.

However for any new settlers in Canberra, it could be a bit hard at the
beginning to find the right area to live in. Canberra has a total of more
than 100 local suburbs and 7 districts (or towncenters as Canberrans
refere to) and most of the facities, entertaiments and large shopping
centers are located in these towncenters. And if you ask any Canberran
for suggestions about the using the public transport system to travel
between these suburbs or towncenters, he/she propaly would recommend
you to get a car as the first thing after you find an accommadation. The
rental cost or property price among these suburbs can also differ to a
large extent based on their locations.

Assume that we have a young family who just moved from interstates or
overseas and would like to purchase a 3 or 4 bedrooms house in Canberra
to settle down. They set a budget for thier property hunting. What would
be the best suburbs that they should look into in terms of propety
price, travel distance to towncenters etc. In this study, I will try to
find the answer for them using the data science skills that I have
acquired during the courses.

* Data
  :PROPERTIES:
  :CUSTOM_ID: data-
  :END:

It is necessary to set out the required dataset for clustering and segmenting the suburbs first before attempting any data collection steps.
As the choice of the interesting suburb to purchase property is mainly based on several aspects such as real estate price and convenience to towncenters and access to local facilities.
After some considerations, I decided to use two different datasets for the suburbs clustering and segmentation analysis.
The main dataset includes the median house price with 3 or 4 bedrooms in each suburb, distance of each suburb to its nearest towncenters and the number of venues within 2km from each suburb's center point.
The second dataset mainly consists of types or category information of venues close to each suburb within the same distance.

During the data collection state, I exercised different methods from webscraping to open datasets which have been covered in previous courses:

- For the list of towncenters and suburbs in Canberra, webscraping was used to extract relevant fields from the table found in the Wikipedia page [[https://en.wikipedia.org/wiki/List_of_Canberra_suburbs][List of Canberra Suburbs]]

- Postcode for each suburb was extracted from an open dataset found on [[https://www.matthewproctor.com/australian_postcodes][Matthew Proctor's website]].

- The latitude and longitude of towncenters and suburbs were retrieved using the geocoder library, whereas the distance from suburb to towncenter was calculated using the [[https://developers.google.com/maps/documentation/distance-matrix][Google Distance Matrix API]] or the Python [[https://pypi.org/project/haversine/][Haversine]] library.

- The number and type of venues around each suburb was retrieved by calling the Forsquare APIs.

- The median prices for 3 or 4 bedrooms houses were scraped from [[https://www.domain.com.au/suburb-profile/][Domain's suburb profile]] page using =requests= and =BeautifulSoup= libraries.

In the following sections, steps to retrieve these data will be explained in more details.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
import numpy as np # library to handle data in a vectorized manner
import matplotlib.pyplot as plt

import pandas as pd # library for data analsysis
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)

import seaborn as sns

from scipy.spatial.distance import cdist

import json # library to handle JSON files

#!pip install geopy
from geopy.geocoders import Nominatim # convert an address into latitude and longitude values

import requests # library to handle requests
from bs4 import BeautifulSoup
from pandas.io.json import json_normalize # tranform JSON file into a pandas dataframe

# Matplotlib and associated plotting modules
import matplotlib.cm as cm
import matplotlib.colors as colors

# import k-means from clustering stage
from sklearn.cluster import KMeans

#!pip install folium=0.5.0|
import folium # map rendering library

print('Libraries imported.')
#+END_SRC

#+results:
: Libraries imported.

** Get towncenter and suburbs list
   :PROPERTIES:
   :CUSTOM_ID: get-towncenter-and-suburbs
   :END:

The first step for data collection was to get a list of towncenters and suburbs which belong to them. It turned out that this dataset with an easy to use format like .csv or spreadsheet is not easily found online.
The Wikipedia page of [[https://en.wikipedia.org/wiki/Suburbs_of_Canberra][Suburbs of Canberra]] includes such information in the expandable tables near the bottom.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
url = "https://en.wikipedia.org/wiki/Suburbs_of_Canberra"
data = requests.get(url).text
soup = BeautifulSoup(data, 'html.parser')
for table in soup.find_all('table'):
    print(table.get('class'))
#+END_SRC

#+results:
#+begin_example
['box-Unreferenced_section', 'plainlinks', 'metadata', 'ambox', 'ambox-content', 'ambox-Unreferenced']
['wikitable']
['nowraplinks', 'mw-collapsible', 'autocollapse', 'navbox-inner']
['nowraplinks', 'mw-collapsible', 'mw-collapsed', 'navbox-subgroup']
['nowraplinks', 'navbox-subgroup']
['nowraplinks', 'navbox-subgroup']
['nowraplinks', 'mw-collapsible', 'mw-collapsed', 'navbox-subgroup']
['nowraplinks', 'navbox-subgroup']
['nowraplinks', 'hlist', 'mw-collapsible', 'autocollapse', 'navbox-inner']
['nowraplinks', 'hlist', 'mw-collapsible', 'autocollapse', 'navbox-inner']
['nowraplinks', 'hlist', 'mw-collapsible', 'autocollapse', 'navbox-inner']
['nowraplinks', 'hlist', 'mw-collapsible', 'autocollapse', 'navbox-inner']
['nowraplinks', 'hlist', 'mw-collapsible', 'autocollapse', 'navbox-inner']
['nowraplinks', 'hlist', 'mw-collapsible', 'autocollapse', 'navbox-inner']
['nowraplinks', 'hlist', 'mw-collapsible', 'autocollapse', 'navbox-inner']
['nowraplinks', 'hlist', 'mw-collapsible', 'autocollapse', 'navbox-inner']
#+end_example

A small challenge here was that those foldable tabels are nested and therefore same information may occure at different hierarchy levels.
After an cross examination between the webpage and the html inspector, I was able to narrow down the innerest talbe that containing the list of suburbs together with their corresponding towncenters.

[[file:figures/canberra_suburbs_wiki.png]]

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
tables = soup.find_all('table',  {'class': ['nowraplinks'] and ['navbox-subgroup']})
table_can = tables[1]
#+END_SRC

#+results:

I decided to separate the /Canberra Central/ district into /North Canberra/ and /South Canberra/ for the analysis.
The html source for each district row corresponds to a =tr= tag, within which are a =th= tag representing the /Towncenter/ name and a =td= tag consisting of an unordered list denoting the suburbs (=ul= tag).


[[file:figures/canberra_suburbs_html.png]]

# Let's define a function to retrieve the towncenter and suburbs from a
# given row:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# Get towncenter and surburbs from each table row
def get_suburbs(trow):
    towncenter = trow.find('th').text
    suburbs = []
    for l in trow.find('td').find_all('li'):
        suburbs.append(l.text)

    return towncenter, suburbs
#+END_SRC

#+results:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# createing the data frame
df = pd.DataFrame(columns=['Towncenter', 'Suburbs'])

for row in table_can.tbody.find_all('tr'):
    if row.find('th').text == 'Canberra Central':
        pass
    else:
        towncenter, suburbs = get_suburbs(row)
        df = df.append({'Towncenter': towncenter, 'Suburbs': suburbs}, ignore_index=True)

# df.head()
#+END_SRC

#+results:

Then I separated each suburb to individual rows and create a new Pandas
DataFrame =df_can=. This will be my master DataFrame for the required
datasets and will be updated as new information is added. Hereafter we
store the =df_can= to individual .csv files at different stages. This
will allow us to read the datasets from stored files instead of
webscraping again for future runs should we wish (for speed or data
consistency concerns).

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# convert suburb list elements to separate rows
# https://www.geeksforgeeks.org/convert-list-like-column-elements-to-separate-rows-in-pandas/
df_can = df['Suburbs'].apply(pd.Series) \
                    .merge(df, right_index=True, left_index=True) \
                    .drop(['Suburbs'], axis=1) \
                    .melt(id_vars=['Towncenter'], value_name='Suburb') \
                    .drop('variable', axis=1) \
                    .dropna()

df_can = df_can.sort_values('Suburb', ascending=True).reset_index(drop=True)
df_can.to_csv('data/canberra_suburbs.csv', index=False)
# df_can.head()
#+END_SRC

#+results:

** Add postcode
   :PROPERTIES:
   :CUSTOM_ID: add-postcode
   :END:

Although the post code for each suburb is not directly used in this
analysis, it is necessary to collect them as I will use it later when
scrap house price information. A FreeDatabase of Australian Postcodes
can be found on [[https://www.matthewproctor.com/australian_postcodes][Matthew Proctor's website]]. Let's download the dataset and read them into a Pandas
DataFrame:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
#df_can = pd.read_csv('data/canberra_suburbs.csv')
df_post = pd.read_csv('data/australian_postcodes.csv')
df_post_act = df_post[(df_post['state'] == 'ACT')][['postcode', 'locality']]
# df_post_act.head()
#+END_SRC

#+results:

Next filter the postcode for Canberra suburbs and merge them into our
previous =df_can= DataFrame:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
df_can = pd.merge(df_can, df_post_act, left_on=df_can['Suburb'].str.upper(), right_on=df_post_act['locality'].str.upper(), how='left').fillna(0)
df_can.drop(['key_0', 'locality'], axis=1, inplace=True)
df_can.rename(columns={'postcode': 'Postcode'}, inplace=True)
df_can['Postcode'] = df_can['Postcode'].astype(int)
df_can = df_can.drop_duplicates(subset=['Suburb'], keep='first')
df_can.to_csv('data/canberra_suburbs_postcode.csv', index=False)
# df_can.head()
#+END_SRC

#+results:

** Add geo location
   :PROPERTIES:
   :CUSTOM_ID: add-geo-location
   :END:

To get the latitude and longitude information for each suburb, let's use
the =geopy= library demonstrated in previous labs:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
from geopy.geocoders import Nominatim
#+END_SRC

#+results:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
#df_can = pd.read_csv('data/canberra_suburbs_postcode.csv')
geolocator = Nominatim(user_agent="act_agent")
print('Obtaining latitude and longitude: ', end='')
df_can['Latitude'] = 0.0
df_can['Longitude'] = 0.0
for index, row in df_can.iterrows():    
    address = '{}, ACT'.format(row['Suburb'])
    location = geolocator.geocode(address)
    df_can.loc[index, 'Latitude'] = location.latitude
    df_can.loc[index, 'Longitude'] = location.longitude
    print(' .', end='')

print(' done.')
df_can.to_csv('data/canberra_suburbs_geo.csv', index=False)
# df_can.head()
#+END_SRC

*** Add towncenters
    :PROPERTIES:
    :CUSTOM_ID: add-towncenters
    :END:

Let's create a seperate DataFrame =df_town= for the towncenters and
their latitude and longitude information. First check if I have all the
8 towncenters included in the master DataFrame:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
df_can['Towncenter'].unique()
#+END_SRC

Looks all right. Now I use geocoder to populate the latitude and
longitude for all the towncenters and store that to a .csv file too.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
df_town = pd.DataFrame(columns=['Towncenter', 'Latitude', 'Longitude'])

for towncenter in df_can['Towncenter'].unique():
    address = '{}, ACT'.format(towncenter)
    location = geolocator.geocode(address)
    df_town = df_town.append({'Towncenter': towncenter, 'Latitude': location.latitude, 'Longitude': location.longitude}, ignore_index=True)
    
df_town.to_csv('data/canberra_towncenters.csv', index=False)    
#df_town.head()
#+END_SRC

*** Visualisation
    :PROPERTIES:
    :CUSTOM_ID: visualisation
    :END:

Based on the geo information of all the suburbs and towncenters, I wanna
visualize them on f Folium map to examine if the data make sense.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
address = 'Canberra, ACT'

geolocator = Nominatim(user_agent="act_explorer")
location = geolocator.geocode(address)
latitude = location.latitude
longitude = location.longitude
print('The geograpical coordinate of Canberra are {}, {}.'.format(latitude, longitude))
#+END_SRC

#+results:
: The geograpical coordinate of Canberra are -35.2975906, 149.1012676.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports results
# create map of Toronto using latitude and longitude values
map_canberra = folium.Map(location=[latitude, longitude], zoom_start=10)

# add markers to suburbs
for lat, lng, towncenter, suburb in zip(df_can['Latitude'], df_can['Longitude'], df_can['Towncenter'], df_can['Suburb']):
    label = '{}, {}'.format(suburb, towncenter)
    label = folium.Popup(label, parse_html=True)
    folium.CircleMarker(
        [lat, lng],
        radius=5,
        popup=label,
        color='blue',
        fill=True,
        fill_color='#3186cc',
        fill_opacity=0.7,
        parse_html=False).add_to(map_canberra)  
    
# add markers to towncenters
for lat, lng, towncenter in zip(df_town['Latitude'], df_town['Longitude'], df_town['Towncenter']):
    label = '{}'.format(towncenter)
    label = folium.Popup(label, parse_html=True)
    folium.CircleMarker(
        [lat, lng],
        radius=30,
        popup=label,
        color='purple',
        fill=True,
        fill_color='#EDE3FF',
        fill_opacity=0.3,
        parse_html=False).add_to(map_canberra)
    
map_canberra
#+END_SRC

#+results:

The visulization looks all right so let's proceed to the next step to
calulate the distance of each suburb to its nearest towncenter.

** Driving distance to nearest Towncenter
   :PROPERTIES:
   :CUSTOM_ID: driving-distance-to-nearest-towncenter
   :END:

My first attempt to calculate the driving distance between suburb to
towncenter is to use
[[https://developers.google.com/maps/documentation/distance-matrix/overview][Google
Distance Matrix API]] following
[[https://www.geeksforgeeks.org/python-calculate-distance-duration-two-places-using-google-distance-matrix-api/][this
blog post]]. Unfortunatly at the time of this study, there is no longer
free options to use the Google Distance Matrix API. As an alternative, I
will explore the
[[https://towardsdatascience.com/calculating-distance-between-two-geolocations-in-python-26ad3afe287b][Haversine
Distance]] as an alternative to the driving distance.

First let's create a DataFrame holding the matrix of suburb (row) and
towncenter (column):

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
  import haversine as hs
#+END_SRC

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
  to_columns = [town for town in df_town['Towncenter']]
  to_columns.append('Nearest')

  df_to = pd.DataFrame(columns=['Suburb']+to_columns)
  df_to['Suburb'] = df_can['Suburb']
  df_to.head()
#+END_SRC

Now iterate each suburb and towncenter and calculate the Haversine
Distance between them. An extra column =Nearest= hold the distance of a
suburb to its closest towncenter which may not necessarily be the
demographic one that it belongs to.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
  # Set towncenter and suburb as index for convenience
  df_to = df_to.set_index('Suburb')
  df_can = df_can.set_index('Suburb')
  df_town = df_town.set_index('Towncenter')
  for town in df_to.columns[:-1]:
      loc_town = (df_town.loc[town, 'Latitude'], df_town.loc[town, 'Longitude'])
      
      for sub in df_to.index.tolist():
          loc_sub = (df_can.loc[sub, 'Latitude'], df_can.loc[sub, 'Longitude'])
          dis = hs.haversine(loc_sub, loc_town)
          df_to.loc[sub, town] = dis
             
  # Nearest distance to towncenter
  df_to['Nearest'] = df_to[df_to.columns[:-1]].min(axis=1)
  # reset index
  df_to = df_to.reset_index()
  df_can = df_can.reset_index()
  df_town = df_town.reset_index()
  df_to.head()
#+END_SRC

Now I can add the nearest distance to towncenter information to our
master DataFraem =df_can=:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
  df_can = pd.merge(df_can, df_to[['Suburb', 'Nearest']], left_on='Suburb', right_on='Suburb', how='inner').fillna(0)
  df_can.to_csv('data/canberra_suburbs_distance.csv', index=False)
  df_can.head()
#+END_SRC

** Add median price
   :PROPERTIES:
   :CUSTOM_ID: add-median-price
   :END:

Again, the dataset for the real estate price for each suburb is not
readily (or at least freely) available online. Domain provides a
[[https://www.domain.com.au/suburb-profile/][suburb profile page]] where
you can enter the name of a suburb and serch its profile which happens
to include a Market trends table. For example, following figure shows
the information
[[https://www.domain.com.au/suburb-profile/banks-act-2906][found in
suburb /Banks/]]:

[[file:figures/domain_price.png]]

The price of properties under interest are 3 or 4 bedrooms house for the young
family who want to settle down in Canberra. A little bit of exploration
on the URLs for each suburb reveals that the suffix part has a pattern
of =suburb-name/act/postcoe= with special character in the suburb name
like single quote or space being replaced by a =-= character. So we
define the following function to scrap the price data for 3/4-bedroom
house:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
  def get_median_price(suburb, postcode):
      suburb = suburb.replace(' ', '-').replace("'", "-")
      url = 'https://www.domain.com.au/suburb-profile/{}-act-{}'.format(suburb.lower(), postcode)

      data = requests.get(url).text
      soup = BeautifulSoup(data, 'html.parser')
      table = soup.find('table',  {'class': ['css-15dn4s8']})

      df = pd.DataFrame(columns=['Bedrooms', 'Type', 'Median Price'])
      try:
          for body in table.find_all('tbody'):
              for row in body.find_all('tr'):
                  columns = row.find_all('td')

                  if(columns != []):
                      bedrooms = columns[0].text.strip()
                      type_ = columns[1].text.strip()
                      price = columns[2].text.strip().replace("$", "")
                      # convert price to numeric values
                      if price == '-':
                          price = None
                      else:
                          price = float(price[:-1]) * (10e3 if price[-1] == 'm' else 1) # convert to float

                      df = df.append({'Bedrooms':bedrooms, 'Type': type_, 'Median Price': price}, ignore_index=True)
      except:
          df = None

      return df
#+END_SRC

It is worth to note that not all suburbs have this Market trends table
as it is based on the sales data in the past 12 months. Additionaly even
the table exists, it is not always to have the price for 3/4 bedroom
house for the very same reason. I will need to take care of these
exceptions during the webscraping proceess and later on I will handle
the missing information for some suburbs.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
  #df_can = pd.read_csv('data/canberra_suburbs_distance.csv')
  print('Obtaining house price: ', end='')
  df_price = pd.DataFrame(columns=['Suburb', 'bed3', 'bed4', 'Median Price'])
  df_price['Suburb'] = df_can['Suburb']

  for index, row in df_can.iterrows():
      suburb = row['Suburb']
      postcode = row['Postcode']
      df = get_median_price(suburb, postcode)
      
      if df is not None:
          df['Bedrooms'] = df['Bedrooms'].astype(int)
          # 3 bedrooms house price
          try:
              # not working
              p = df[(df['Type']=='House') & (df['Bedrooms']==3)]['Median Price'].values[0]
              df_price['bed3'][index] = p
          except:
              pass
          
          # 4 bedrooms house price
          try:
              p = df[(df['Type']=='House') & (df['Bedrooms']==4)]['Median Price'].values[0]
              df_price['bed4'][index] = p
          except:
              pass

      print(' .', end='')

  print(' done.')
  df_price.head()
#+END_SRC

*** Fixing missing prices
    :PROPERTIES:
    :CUSTOM_ID: fixing-missing-prices
    :END:

Let's first check the number of suburbs that I didn't find a price for
3/4-bedroom houses as well as the number of thouse only has either 3 or
4-bedrooms:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
no_bed3_and_bed4 = df_price['bed3'].isnull() & df_price['bed4'].isnull()
no_bed3 = df_price['bed3'].isnull() & df_price['bed4'].notnull()
no_bed4 = df_price['bed3'].notnull() & df_price['bed4'].isnull()
total = df_price.shape[0]

print('No price for both 3 and 4 bedrooms: {}, missing {:.2f}%'.format(no_bed3_and_bed4.sum(), 
                                                                    no_bed3_and_bed4.sum()*100/total))
print('No price for 3 bedrooms: {}, missing {:.2f}%'.format(no_bed3.sum(),
                                                          no_bed3.sum()*100/total))
print('No price for 4 bedrooms: {}, missing {:.2f}%'.format(no_bed4.sum(),
                                                           no_bed4.sum()*100/total))
#+END_SRC

The missing rates for only 3 or 4 bedrooms are below 10% whereas missing
rate for both 3 and 4 bedrooms are even higher 28%. Instead of dumping
the rows with missing values or using the column mean to fill in the
missing values directly which is likely to insert many same price
values, I use the following strategy to fix the missing prices:

1. Assume the ratio for 4-bedroom and 3-bedroom price is similar in all
   the suburbs, calculate this ratio based on the average of suburbs
   which contain both values.
2. For the suburbs mising only one price, let's use the other price and
   the above average ratio to estimate the other missing price.
3. Finally for suburbs missing both prices, use the column mean
   respectively.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
#1. calculate mean ration between 3 and 4 bedroom house price
df_p = df_price[df_price['bed3'].notnull() & df_price['bed4'].notnull()]
scale = (df_p['bed4'] / df_p['bed3']).mean()
#2. pupulating missing price using the mean scale based on the other existing price
df_price['bed4'][no_bed4] = df_price[no_bed4]['bed3'] * scale
df_price['bed3'][no_bed3] = df_price[no_bed3]['bed4'] / scale
#3. for those missing both 3&4 bedrooms, using the column mean
df_price['bed3'].fillna(value=df_price['bed3'].mean(), inplace=True)
df_price['bed4'].fillna(value=df_price['bed4'].mean(), inplace=True)
df_price.head()
#+END_SRC

Now calulate an average price for 3 and 4 bedrooms house and merge that
information into the master DataFrame =df_can=:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
  df_price['Median Price'] = df_price[['bed3', 'bed4']].mean(axis=1)

  df_can = df_can.merge(df_price[['Suburb', 'Median Price']], left_on='Suburb', right_on='Suburb', how='inner')
  df_can.to_csv('data/canberra_suburbs_price.csv', index=False)
  df_can.head()
#+END_SRC

** Use Foursquare to check venues
   :PROPERTIES:
   :CUSTOM_ID: use-foursquare-to-check-venues
   :END:

Similar to previous labs covered in the course, I will use the
Foursquare API to explore the venues around each suburb and catagarize
them. First define some credentials and a function to reteive venue
information for a list of suburbs:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
CLIENT_ID = 'NA1JN3DQJULNX1LDJ00TD14RADCEPYZDJ1KSZEHK1LMVATL1' # your Foursquare ID
CLIENT_SECRET = 'RWZA2UXX3T1CENZTGVAWJ11FQRXSKO3B50NLOCAPLBIZ0NJY' # your Foursquare Secret
VERSION = '20180605' # Foursquare API version
LIMIT = 100 # A default Foursquare API limit value
#+END_SRC

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
def getNearbyVenues(names, latitudes, longitudes, radius=500):
    
    print('Obtaining venue information: ', end='')
    venues_list=[]
    for name, lat, lng in zip(names, latitudes, longitudes):            
        # create the API request URL
        url = 'https://api.foursquare.com/v2/venues/explore?&client_id={}&client_secret={}&v={}&ll={},{}&radius={}&limit={}'.format(
            CLIENT_ID, 
            CLIENT_SECRET, 
            VERSION, 
            lat, 
            lng, 
            radius, 
            LIMIT)
            
        # make the GET request
        results = requests.get(url).json()["response"]['groups'][0]['items']
        
        # return only relevant information for each nearby venue
        venues_list.append([(
            name, 
            lat, 
            lng, 
            v['venue']['name'], 
            v['venue']['location']['lat'], 
            v['venue']['location']['lng'],  
            v['venue']['categories'][0]['name']) for v in results])
        print(' .', end='')

    nearby_venues = pd.DataFrame([item for venue_list in venues_list for item in venue_list])
    nearby_venues.columns = ['Suburb', 
                  'Suburb Latitude', 
                  'Suburb Longitude', 
                  'Venue', 
                  'Venue Latitude', 
                  'Venue Longitude', 
                  'Venue Category']
    
    print(' done.')
    return(nearby_venues)
#+END_SRC

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
#df_can = pd.read_csv('data/canberra_suburbs_price.csv')
canberra_venues = getNearbyVenues(names=df_can['Suburb'],
                                latitudes=df_can['Latitude'],
                                longitudes=df_can['Longitude'],
                                radius=2000
                                )
#+END_SRC

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
print('There are {} total categories.'.format(canberra_venues.shape[0]))
print('There are {} uniques categories.'.format(len(canberra_venues['Venue Category'].unique())))
canberra_venues.to_csv('data/canberra_venues.csv', index=False)
canberra_venues.head()
#+END_SRC

Now I count the number of venues in each suburb and merge that into
master DataFrame =df_can=. This colcludes the end of main data
collection:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
df_count = canberra_venues.groupby(['Suburb'])['Suburb'].count().reset_index(name='venue count')
df_can = df_can.merge(df_count, left_on='Suburb', right_on='Suburb', how='left').fillna(0)
df_can.to_csv('data/canberra_suburbs_venues.csv', index=False)
df_can.head()
#+END_SRC

The master DataFrame =df_can= now looks like below:
#+BEGIN_SRC jupyter-python :session py3 :async yes :exports results :pandoc t
df_can.head()
#+END_SRC

#+results:
:RESULTS:
|   | Suburb  | Towncenter     | Postcode | Latitude   | Longitude  | Nearest  | Median Price | venue count |
|---+---------+----------------+----------+------------+------------+----------+--------------+-------------|
| 0 | Acton   | North Canberra | 2601     | -35.285232 | 149.112968 | 2.921057 | 3044.733334  | 100.0       |
| 1 | Ainslie | North Canberra | 2602     | -35.262195 | 149.147880 | 1.413531 | 14295.000000 | 61.0        |
| 2 | Amaroo  | Gungahlin      | 2914     | -35.169587 | 149.128021 | 1.106799 | 726.000000   | 38.0        |
| 3 | Aranda  | Belconnen      | 2614     | -35.258055 | 149.080426 | 4.783948 | 3044.733334  | 29.0        |
| 4 | Banks   | Tuggeranong    | 2906     | -35.471889 | 149.099657 | 5.702031 | 655.000000   | 9.0         |
:END:

*** Analyze venues in each suburb
    :PROPERTIES:
    :CUSTOM_ID: analyze-venues-in-each-suburb
    :END:

In this part, I find the top 5 most common venues in each suburb,
following the examples from previous labs, and store them as an
additional DataFrame =df_can= in addition to the master DataFrame:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
canberra_venues = pd.read_csv('data/canberra_venues.csv')

# one hot encoding
canberra_onehot = pd.get_dummies(canberra_venues[['Venue Category']], prefix="", prefix_sep="")

# add neighborhood column back to dataframe
canberra_onehot['Suburb'] = canberra_venues['Suburb'] 

# move neighborhood column to the first column
fixed_columns = [canberra_onehot.columns[-1]] + list(canberra_onehot.columns[:-1])
canberra_onehot = canberra_onehot[fixed_columns]

canberra_onehot.head()
#+END_SRC

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
canberra_grouped = canberra_onehot.groupby('Suburb').mean().reset_index()
canberra_grouped.shape
#+END_SRC

Now let's create the new dataframe and display the top 10 venues for
each suburb by writing a function to sort the venues in descending
order:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
def return_most_common_venues(row, num_top_venues):
    row_categories = row.iloc[1:]
    row_categories_sorted = row_categories.sort_values(ascending=False)
    
    return row_categories_sorted.index.values[0:num_top_venues]
#+END_SRC

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
num_top_venues = 10

indicators = ['st', 'nd', 'rd']

# create columns according to number of top venues
columns = ['Suburb']
for ind in np.arange(num_top_venues):
    try:
        columns.append('{}{} Most Common Venue'.format(ind+1, indicators[ind]))
    except:
        columns.append('{}th Most Common Venue'.format(ind+1))

# create a new dataframe
df_venues = pd.DataFrame(columns=columns)
df_venues['Suburb'] = canberra_grouped['Suburb']

for ind in np.arange(canberra_grouped.shape[0]):
    df_venues.iloc[ind, 1:] = return_most_common_venues(canberra_grouped.iloc[ind, :], num_top_venues)

df_venues.to_csv('data/canberra_venues_sorted.csv', index=False)
df_venues.head()
#+END_SRC


* Methodology
  :PROPERTIES:
  :CUSTOM_ID: methodology-
  :END:
In this study, I will try to categrize suburbs into different groups
with similar profiles based on different metrics. In the previous data
collection stage, I have assembed two Pandas DataFrames: one consists
of the meian price for 3 to 4 bedroom houses, distance to closest
towncenter and total number of venues in each suburb within 2km. Whereas
the second DataFrame consists of the top 10 most common venues in each
suburb.

In the next analysis step, I will first *check some statistics* of our
dataset, for example, histogram of house prices and cloest distance to
towncenter. Then I perform unsupervised *k-means clustering* on these
two datasets to cluster and segment suburbs. After clustering, I will
visiualize the clustered suburbs using Folium. *Choropleth* maps are
expected to be used to assist visulisation of venue density or price
range etc.

By the end of the study, I should have well segmented suburbs and be
able to give recommendations to the young family seeking for properties
according to different criteria.

* Analysis
  :PROPERTIES:
  :CUSTOM_ID: analysis-
  :END:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# uncomment if use stored data
df_can = pd.read_csv('data/canberra_suburbs_venues.csv')
df_venues = pd.read_csv('data/canberra_venues_sorted.csv')
#+END_SRC

#+results:

** Get some statitics
   :PROPERTIES:
   :CUSTOM_ID: get-some-statitics
   :END:

Let's first perform some basic explanatory data analysis on the main
DataFrame. I will explore statitics of median house price, number of
venues and distance to nearest towncenters for each suburb grouped by
their governing towncenters. Pandas boxplot is used instead of the
seaborn library but with adjusted style.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# We will use the boxplot from Pandas as it provides groupby by default,
# but adjust the default style: https://stackoverflow.com/a/35197282

def adjust_boxplot_style(bp):
    # boxplot style adjustments
    [[item.set_linewidth(4) for item in bp[key]['boxes']] for key in bp.keys()]
    [[item.set_linewidth(4) for item in bp[key]['fliers']] for key in bp.keys()]
    [[item.set_linewidth(4) for item in bp[key]['medians']] for key in bp.keys()]
    [[item.set_linewidth(4) for item in bp[key]['means']] for key in bp.keys()]
    [[item.set_linewidth(4) for item in bp[key]['whiskers']] for key in bp.keys()]
    [[item.set_linewidth(4) for item in bp[key]['caps']] for key in bp.keys()]

    [[item.set_color('g') for item in bp[key]['boxes']] for key in bp.keys()]
    # seems to have no effect
    [[item.set_color('b') for item in bp[key]['fliers']] for key in bp.keys()]
    [[item.set_color('m') for item in bp[key]['medians']] for key in bp.keys()]
    [[item.set_markerfacecolor('k') for item in bp[key]['means']] for key in bp.keys()]
    [[item.set_color('c') for item in bp[key]['whiskers']] for key in bp.keys()]
    [[item.set_color('y') for item in bp[key]['caps']] for key in bp.keys()]
#+END_SRC

#+results:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports results :file figures/suburb_statistics_towncenters.jpg
boxprops = dict(linestyle='-', linewidth=4, color='k')
medianprops = dict(linestyle='-', linewidth=4, color='k')

fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(24, 6))

bp1 = df_can.boxplot(column='Median Price',by='Towncenter', ax=ax1,
                    showfliers=True, showmeans=True,
                    boxprops=boxprops, medianprops=medianprops,
                    return_type='dict')

bp2 = df_can.boxplot(column='venue count',by='Towncenter', ax=ax2,
                    showfliers=True, showmeans=True,
                    boxprops=boxprops, medianprops=medianprops,
                    return_type='dict')

bp3 = df_can.boxplot(column='Nearest',by='Towncenter', ax=ax3,
                    showfliers=True, showmeans=True,
                    boxprops=boxprops, medianprops=medianprops,
                    return_type='dict')

# boxplot style adjustments
adjust_boxplot_style(bp1)
adjust_boxplot_style(bp2)
adjust_boxplot_style(bp3)

# get rid of "boxplot grouped by" title
plt.suptitle("")

# label adjustment
ax1.set_title("Median price for suburbs \nin different towncenters", fontsize=20)
ax1.set_ylabel('Median Price (K)', fontsize=20)
ax1.set_xlabel('')
ax1.tick_params(axis='y', labelsize=20)
ax1.tick_params(axis='x', labelsize=20)
ax1.tick_params(axis="x", rotation=45)

ax2.set_title("Venue count for suburbs \nin different towncenters", fontsize=20)
ax2.set_ylabel('Venue numbers', fontsize=20)
ax2.set_xlabel('')
ax2.tick_params(axis='y', labelsize=20)
ax2.tick_params(axis='x', labelsize=20)
ax2.tick_params(axis="x", rotation=45)

ax3.set_title("Distance to nearest townceters for suburbs \nin different towncenters", fontsize=20)
ax3.set_ylabel('Distance (km)', fontsize=20)
ax3.set_xlabel('')
ax3.tick_params(axis='y', labelsize=20)
ax3.tick_params(axis='x', labelsize=20)
ax3.tick_params(axis="x", rotation=45)
#+END_SRC

#+results:
[[file:figures/suburb_statistics_towncenters.jpg]]

From the above 3 plots, I can see that there are more venues in North
and South Canberras and the house price there are also much higher than
suburbs in other towncenters. The distance for suburbs to closed
towncenter however does not present a significant difference which
indicate the well planned geo structure of Canberra suburbs. Next we
will use k-means to cluster all the suburbs.

** k-means clustering on master dataset
   :PROPERTIES:
   :CUSTOM_ID: k-means-clustering-on-master-dataset
   :END:

In this section, I will use k-means to perform unsupervised clustering
on the master dataset =df_can= and the venue category dataset
=df_venues=. To find the optimal number of clusters, the elbow method
will be used.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
#df_can = pd.read_csv('data/canberra_suburbs_venues.csv')
drop_columns = ['Towncenter', 'Postcode', 'Latitude', 'Longitude']
df_cluster = df_can.drop(drop_columns, axis=1).set_index('Suburb')
#df_cluster.head()
#+END_SRC

#+results:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# normalize datasets
from sklearn.preprocessing import StandardScaler
X = df_cluster.values[:,:]
X = np.nan_to_num(X)
clus_data = StandardScaler().fit_transform(X)
clus_data.shape
#+END_SRC

#+results:
| 112 | 3 |

To find optimal cluster number, I iterate from 1 to 10 and find the
turning point:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports results :results file
distortions = []
K = range(1,10)
for k in K:
    kmeanModel = KMeans(n_clusters=k, random_state=0).fit(clus_data)
    distortions.append(sum(np.min(cdist(clus_data, kmeanModel.cluster_centers_, 'canberra'), axis=1)) / clus_data.shape[0])

#There are different metric distance function for spatial distance. 
#I choose correlation instaed of euclidean because the canberra function gives me more clear view of elbow break point.

# Plot the elbow
fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(K, distortions, 'bx-')
ax.set_xlabel('k')
ax.set_ylabel('Distortion')
ax.set_title('The Elbow Method showing the optimal k')
plt.savefig('figures/kmeans-optimal-master.pdf')
#+END_SRC

#+results:
[[file:./.ob-jupyter/c0eee727770411c6226540bf7e22b6aed5a8986e.png]]

So 3 would be the optimal number of clusters and let's rerun the
clustering:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# set number of clusters
kclusters = 3
# run k-means clustering
kmeans = KMeans(n_clusters=kclusters, random_state=0).fit(clus_data)
kmeans.labels_
#+END_SRC

#+results:
: array([2, 2, 1, 0, 0, 2, 1, 0, 1, 2, 0, 1, 2, 2, 0, 1, 0, 2, 0, 2, 0, 0,
:        1, 0, 0, 2, 1, 2, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 2, 0, 0, 0, 1, 0,
:        0, 0, 1, 1, 2, 1, 0, 0, 1, 1, 1, 0, 2, 0, 1, 1, 0, 0, 0, 2, 1, 0,
:        1, 2, 0, 0, 0, 2, 1, 0, 1, 0, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 2,
:        2, 1, 2, 2, 1, 1, 2, 1, 0, 1, 0, 0, 0, 0, 1, 2, 1, 1, 0, 2, 1, 0,
:        1, 2], dtype=int32)

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# insert the cluster label to DataFrame
df_cluster = df_can.copy()
df_cluster.insert(0, 'Cluster', kmeans.labels_)
df_cluster.reset_index()
# df_cluster.head()
#+END_SRC

#+results:
#+begin_export html
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>index</th>
      <th>Cluster</th>
      <th>Suburb</th>
      <th>Towncenter</th>
      <th>Postcode</th>
      <th>Latitude</th>
      <th>Longitude</th>
      <th>Nearest</th>
      <th>Median Price</th>
      <th>venue count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>2</td>
      <td>Acton</td>
      <td>North Canberra</td>
      <td>2601</td>
      <td>-35.285232</td>
      <td>149.112968</td>
      <td>2.921057</td>
      <td>3044.733334</td>
      <td>100.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>2</td>
      <td>Ainslie</td>
      <td>North Canberra</td>
      <td>2602</td>
      <td>-35.262195</td>
      <td>149.147880</td>
      <td>1.413531</td>
      <td>14295.000000</td>
      <td>61.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>1</td>
      <td>Amaroo</td>
      <td>Gungahlin</td>
      <td>2914</td>
      <td>-35.169587</td>
      <td>149.128021</td>
      <td>1.106799</td>
      <td>726.000000</td>
      <td>38.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>0</td>
      <td>Aranda</td>
      <td>Belconnen</td>
      <td>2614</td>
      <td>-35.258055</td>
      <td>149.080426</td>
      <td>4.783948</td>
      <td>3044.733334</td>
      <td>29.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>0</td>
      <td>Banks</td>
      <td>Tuggeranong</td>
      <td>2906</td>
      <td>-35.471889</td>
      <td>149.099657</td>
      <td>5.702031</td>
      <td>655.000000</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>5</td>
      <td>2</td>
      <td>Barton</td>
      <td>South Canberra</td>
      <td>2600</td>
      <td>-35.307263</td>
      <td>149.140499</td>
      <td>1.294751</td>
      <td>3044.733334</td>
      <td>92.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>6</td>
      <td>1</td>
      <td>Belconnen</td>
      <td>Belconnen</td>
      <td>2616</td>
      <td>-35.227434</td>
      <td>149.043145</td>
      <td>0.000000</td>
      <td>3044.733334</td>
      <td>12.0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>7</td>
      <td>0</td>
      <td>Bonner</td>
      <td>Gungahlin</td>
      <td>2914</td>
      <td>-35.155962</td>
      <td>149.142956</td>
      <td>3.093818</td>
      <td>683.500000</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>8</th>
      <td>8</td>
      <td>1</td>
      <td>Bonython</td>
      <td>Tuggeranong</td>
      <td>2905</td>
      <td>-35.433308</td>
      <td>149.078276</td>
      <td>1.859237</td>
      <td>687.500000</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>9</th>
      <td>9</td>
      <td>2</td>
      <td>Braddon</td>
      <td>North Canberra</td>
      <td>2612</td>
      <td>-35.270815</td>
      <td>149.135735</td>
      <td>0.771686</td>
      <td>3044.733334</td>
      <td>93.0</td>
    </tr>
    <tr>
      <th>10</th>
      <td>10</td>
      <td>0</td>
      <td>Bruce</td>
      <td>Belconnen</td>
      <td>2617</td>
      <td>-35.245352</td>
      <td>149.091633</td>
      <td>4.275146</td>
      <td>3044.733334</td>
      <td>28.0</td>
    </tr>
    <tr>
      <th>11</th>
      <td>11</td>
      <td>1</td>
      <td>Calwell</td>
      <td>Tuggeranong</td>
      <td>2905</td>
      <td>-35.440386</td>
      <td>149.107107</td>
      <td>2.549109</td>
      <td>677.500000</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>12</th>
      <td>12</td>
      <td>2</td>
      <td>Campbell</td>
      <td>North Canberra</td>
      <td>2612</td>
      <td>-35.291340</td>
      <td>149.158176</td>
      <td>3.683473</td>
      <td>14565.000000</td>
      <td>34.0</td>
    </tr>
    <tr>
      <th>13</th>
      <td>13</td>
      <td>2</td>
      <td>Capital Hill</td>
      <td>South Canberra</td>
      <td>2600</td>
      <td>-35.308180</td>
      <td>149.124421</td>
      <td>1.086058</td>
      <td>3044.733334</td>
      <td>100.0</td>
    </tr>
    <tr>
      <th>14</th>
      <td>14</td>
      <td>0</td>
      <td>Casey</td>
      <td>Gungahlin</td>
      <td>2913</td>
      <td>-35.167002</td>
      <td>149.094715</td>
      <td>2.943163</td>
      <td>679.000000</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>15</th>
      <td>15</td>
      <td>1</td>
      <td>Chapman</td>
      <td>Weston Creek</td>
      <td>2611</td>
      <td>-35.356209</td>
      <td>149.037454</td>
      <td>1.705724</td>
      <td>6954.724984</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>16</th>
      <td>16</td>
      <td>0</td>
      <td>Charnwood</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.200178</td>
      <td>149.034136</td>
      <td>3.139327</td>
      <td>1119.328062</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>17</th>
      <td>17</td>
      <td>2</td>
      <td>Chifley</td>
      <td>Woden Valley</td>
      <td>2606</td>
      <td>-35.353295</td>
      <td>149.076890</td>
      <td>1.602380</td>
      <td>6688.004946</td>
      <td>36.0</td>
    </tr>
    <tr>
      <th>18</th>
      <td>18</td>
      <td>0</td>
      <td>Chisholm</td>
      <td>Tuggeranong</td>
      <td>2905</td>
      <td>-35.421966</td>
      <td>149.124845</td>
      <td>2.966122</td>
      <td>685.500000</td>
      <td>17.0</td>
    </tr>
    <tr>
      <th>19</th>
      <td>19</td>
      <td>2</td>
      <td>City</td>
      <td>North Canberra</td>
      <td>2601</td>
      <td>-35.281268</td>
      <td>149.129187</td>
      <td>1.902094</td>
      <td>3044.733334</td>
      <td>100.0</td>
    </tr>
    <tr>
      <th>20</th>
      <td>20</td>
      <td>0</td>
      <td>Conder</td>
      <td>Tuggeranong</td>
      <td>2906</td>
      <td>-35.459273</td>
      <td>149.104328</td>
      <td>4.399307</td>
      <td>648.000000</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>21</th>
      <td>21</td>
      <td>0</td>
      <td>Cook</td>
      <td>Belconnen</td>
      <td>2614</td>
      <td>-35.260103</td>
      <td>149.066366</td>
      <td>4.200379</td>
      <td>3044.733334</td>
      <td>31.0</td>
    </tr>
    <tr>
      <th>22</th>
      <td>22</td>
      <td>1</td>
      <td>Coombs</td>
      <td>Molonglo Valley</td>
      <td>2611</td>
      <td>-35.316734</td>
      <td>149.042525</td>
      <td>1.623548</td>
      <td>788.500000</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>23</th>
      <td>23</td>
      <td>0</td>
      <td>Crace</td>
      <td>Gungahlin</td>
      <td>2911</td>
      <td>-35.202880</td>
      <td>149.107474</td>
      <td>3.047059</td>
      <td>776.000000</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>24</th>
      <td>24</td>
      <td>0</td>
      <td>Curtin</td>
      <td>Woden Valley</td>
      <td>2605</td>
      <td>-35.324632</td>
      <td>149.077378</td>
      <td>3.186627</td>
      <td>6244.000000</td>
      <td>11.0</td>
    </tr>
    <tr>
      <th>25</th>
      <td>25</td>
      <td>2</td>
      <td>Deakin</td>
      <td>South Canberra</td>
      <td>2600</td>
      <td>-35.319275</td>
      <td>149.103076</td>
      <td>2.584546</td>
      <td>15165.000000</td>
      <td>20.0</td>
    </tr>
    <tr>
      <th>26</th>
      <td>26</td>
      <td>1</td>
      <td>Denman Prospect</td>
      <td>Molonglo Valley</td>
      <td>2611</td>
      <td>-35.296415</td>
      <td>149.024810</td>
      <td>1.154765</td>
      <td>658.798493</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>27</th>
      <td>27</td>
      <td>2</td>
      <td>Dickson</td>
      <td>North Canberra</td>
      <td>2602</td>
      <td>-35.252786</td>
      <td>149.141722</td>
      <td>1.535347</td>
      <td>1898.860106</td>
      <td>58.0</td>
    </tr>
    <tr>
      <th>28</th>
      <td>28</td>
      <td>1</td>
      <td>Downer</td>
      <td>North Canberra</td>
      <td>2602</td>
      <td>-35.243831</td>
      <td>149.143546</td>
      <td>2.494032</td>
      <td>952.500000</td>
      <td>58.0</td>
    </tr>
    <tr>
      <th>29</th>
      <td>29</td>
      <td>1</td>
      <td>Duffy</td>
      <td>Weston Creek</td>
      <td>2611</td>
      <td>-35.334552</td>
      <td>149.031900</td>
      <td>1.745455</td>
      <td>789.000000</td>
      <td>11.0</td>
    </tr>
    <tr>
      <th>30</th>
      <td>30</td>
      <td>0</td>
      <td>Dunlop</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.193997</td>
      <td>149.019801</td>
      <td>4.280316</td>
      <td>659.000000</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>31</th>
      <td>31</td>
      <td>0</td>
      <td>Evatt</td>
      <td>Belconnen</td>
      <td>2617</td>
      <td>-35.211832</td>
      <td>149.068948</td>
      <td>2.916102</td>
      <td>739.000000</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>32</th>
      <td>32</td>
      <td>0</td>
      <td>Fadden</td>
      <td>Tuggeranong</td>
      <td>2904</td>
      <td>-35.401862</td>
      <td>149.117610</td>
      <td>3.138207</td>
      <td>600.120085</td>
      <td>28.0</td>
    </tr>
    <tr>
      <th>33</th>
      <td>33</td>
      <td>0</td>
      <td>Farrer</td>
      <td>Woden Valley</td>
      <td>2607</td>
      <td>-35.376690</td>
      <td>149.105038</td>
      <td>3.145545</td>
      <td>6222.500000</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>34</th>
      <td>34</td>
      <td>1</td>
      <td>Fisher</td>
      <td>Weston Creek</td>
      <td>2611</td>
      <td>-35.361263</td>
      <td>149.056876</td>
      <td>2.150464</td>
      <td>763.000000</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>35</th>
      <td>35</td>
      <td>1</td>
      <td>Florey</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.225790</td>
      <td>149.050175</td>
      <td>0.664135</td>
      <td>732.000000</td>
      <td>34.0</td>
    </tr>
    <tr>
      <th>36</th>
      <td>36</td>
      <td>1</td>
      <td>Flynn</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.205837</td>
      <td>149.044063</td>
      <td>2.402917</td>
      <td>727.500000</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>37</th>
      <td>37</td>
      <td>1</td>
      <td>Forde</td>
      <td>Gungahlin</td>
      <td>2914</td>
      <td>-35.168224</td>
      <td>149.146069</td>
      <td>2.356815</td>
      <td>782.500000</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>38</th>
      <td>38</td>
      <td>2</td>
      <td>Forrest</td>
      <td>South Canberra</td>
      <td>2603</td>
      <td>-35.317209</td>
      <td>149.124856</td>
      <td>0.596617</td>
      <td>3044.733334</td>
      <td>73.0</td>
    </tr>
    <tr>
      <th>39</th>
      <td>39</td>
      <td>0</td>
      <td>Franklin</td>
      <td>Gungahlin</td>
      <td>2913</td>
      <td>-35.199454</td>
      <td>149.143301</td>
      <td>2.902183</td>
      <td>730.000000</td>
      <td>24.0</td>
    </tr>
    <tr>
      <th>40</th>
      <td>40</td>
      <td>0</td>
      <td>Fraser</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.191712</td>
      <td>149.045318</td>
      <td>3.976945</td>
      <td>3044.733334</td>
      <td>11.0</td>
    </tr>
    <tr>
      <th>41</th>
      <td>41</td>
      <td>0</td>
      <td>Fyshwick</td>
      <td>South Canberra</td>
      <td>2609</td>
      <td>-35.321658</td>
      <td>149.170877</td>
      <td>3.641686</td>
      <td>3044.733334</td>
      <td>45.0</td>
    </tr>
    <tr>
      <th>42</th>
      <td>42</td>
      <td>1</td>
      <td>Garran</td>
      <td>Woden Valley</td>
      <td>2605</td>
      <td>-35.341397</td>
      <td>149.108539</td>
      <td>1.616345</td>
      <td>8988.465272</td>
      <td>11.0</td>
    </tr>
    <tr>
      <th>43</th>
      <td>43</td>
      <td>0</td>
      <td>Gilmore</td>
      <td>Tuggeranong</td>
      <td>2905</td>
      <td>-35.415011</td>
      <td>149.138278</td>
      <td>4.233777</td>
      <td>674.500000</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>44</th>
      <td>44</td>
      <td>0</td>
      <td>Giralang</td>
      <td>Belconnen</td>
      <td>2617</td>
      <td>-35.210939</td>
      <td>149.095992</td>
      <td>4.361993</td>
      <td>776.000000</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>45</th>
      <td>45</td>
      <td>0</td>
      <td>Gordon</td>
      <td>Tuggeranong</td>
      <td>2906</td>
      <td>-35.456726</td>
      <td>149.085066</td>
      <td>4.026384</td>
      <td>665.000000</td>
      <td>11.0</td>
    </tr>
    <tr>
      <th>46</th>
      <td>46</td>
      <td>1</td>
      <td>Gowrie</td>
      <td>Tuggeranong</td>
      <td>2904</td>
      <td>-35.411817</td>
      <td>149.109106</td>
      <td>1.844741</td>
      <td>3044.733334</td>
      <td>22.0</td>
    </tr>
    <tr>
      <th>47</th>
      <td>47</td>
      <td>1</td>
      <td>Greenway</td>
      <td>Tuggeranong</td>
      <td>2900</td>
      <td>-35.415808</td>
      <td>149.064815</td>
      <td>2.541443</td>
      <td>3044.733334</td>
      <td>26.0</td>
    </tr>
    <tr>
      <th>48</th>
      <td>48</td>
      <td>2</td>
      <td>Griffith</td>
      <td>South Canberra</td>
      <td>2603</td>
      <td>-35.325350</td>
      <td>149.137130</td>
      <td>1.149409</td>
      <td>16830.000000</td>
      <td>93.0</td>
    </tr>
    <tr>
      <th>49</th>
      <td>49</td>
      <td>1</td>
      <td>Gungahlin</td>
      <td>Gungahlin</td>
      <td>2912</td>
      <td>-35.178878</td>
      <td>149.123653</td>
      <td>0.000000</td>
      <td>755.000000</td>
      <td>29.0</td>
    </tr>
    <tr>
      <th>50</th>
      <td>50</td>
      <td>0</td>
      <td>Hackett</td>
      <td>North Canberra</td>
      <td>2602</td>
      <td>-35.249509</td>
      <td>149.163544</td>
      <td>3.264742</td>
      <td>6606.500000</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>51</th>
      <td>51</td>
      <td>0</td>
      <td>Harrison</td>
      <td>Gungahlin</td>
      <td>2914</td>
      <td>-35.199060</td>
      <td>149.156126</td>
      <td>3.707349</td>
      <td>679.500000</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>52</th>
      <td>52</td>
      <td>1</td>
      <td>Hawker</td>
      <td>Belconnen</td>
      <td>2614</td>
      <td>-35.247044</td>
      <td>149.036697</td>
      <td>2.257885</td>
      <td>3044.733334</td>
      <td>8.0</td>
    </tr>
    <tr>
      <th>53</th>
      <td>53</td>
      <td>1</td>
      <td>Higgins</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.232407</td>
      <td>149.027232</td>
      <td>1.547605</td>
      <td>689.500000</td>
      <td>17.0</td>
    </tr>
    <tr>
      <th>54</th>
      <td>54</td>
      <td>1</td>
      <td>Holder</td>
      <td>Weston Creek</td>
      <td>2611</td>
      <td>-35.334483</td>
      <td>149.046168</td>
      <td>1.002174</td>
      <td>752.500000</td>
      <td>23.0</td>
    </tr>
    <tr>
      <th>55</th>
      <td>55</td>
      <td>0</td>
      <td>Holt</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.224396</td>
      <td>149.011929</td>
      <td>2.855497</td>
      <td>643.500000</td>
      <td>13.0</td>
    </tr>
    <tr>
      <th>56</th>
      <td>56</td>
      <td>2</td>
      <td>Hughes</td>
      <td>Woden Valley</td>
      <td>2605</td>
      <td>-35.332625</td>
      <td>149.094943</td>
      <td>1.917944</td>
      <td>6505.000000</td>
      <td>32.0</td>
    </tr>
    <tr>
      <th>57</th>
      <td>57</td>
      <td>0</td>
      <td>Hume</td>
      <td>Tuggeranong</td>
      <td>2620</td>
      <td>-35.385382</td>
      <td>149.165847</td>
      <td>7.614914</td>
      <td>3044.733334</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>58</th>
      <td>58</td>
      <td>1</td>
      <td>Isaacs</td>
      <td>Woden Valley</td>
      <td>2607</td>
      <td>-35.368471</td>
      <td>149.113099</td>
      <td>2.695934</td>
      <td>5652.500000</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>59</th>
      <td>59</td>
      <td>1</td>
      <td>Isabella Plains</td>
      <td>Tuggeranong</td>
      <td>2905</td>
      <td>-35.428007</td>
      <td>149.094009</td>
      <td>0.799956</td>
      <td>639.000000</td>
      <td>11.0</td>
    </tr>
    <tr>
      <th>60</th>
      <td>60</td>
      <td>0</td>
      <td>Jacka</td>
      <td>Gungahlin</td>
      <td>2914</td>
      <td>-35.149516</td>
      <td>149.130430</td>
      <td>3.322507</td>
      <td>3044.733334</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>61</th>
      <td>61</td>
      <td>0</td>
      <td>Kaleen</td>
      <td>Belconnen</td>
      <td>2617</td>
      <td>-35.227787</td>
      <td>149.109139</td>
      <td>4.590837</td>
      <td>846.000000</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>62</th>
      <td>62</td>
      <td>0</td>
      <td>Kambah</td>
      <td>Tuggeranong</td>
      <td>2902</td>
      <td>-35.386229</td>
      <td>149.057967</td>
      <td>4.851143</td>
      <td>699.000000</td>
      <td>12.0</td>
    </tr>
    <tr>
      <th>63</th>
      <td>63</td>
      <td>2</td>
      <td>Kingston</td>
      <td>South Canberra</td>
      <td>2604</td>
      <td>-35.315230</td>
      <td>149.146592</td>
      <td>1.390824</td>
      <td>3044.733334</td>
      <td>96.0</td>
    </tr>
    <tr>
      <th>64</th>
      <td>64</td>
      <td>1</td>
      <td>Latham</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.216391</td>
      <td>149.031639</td>
      <td>1.612486</td>
      <td>682.000000</td>
      <td>17.0</td>
    </tr>
    <tr>
      <th>65</th>
      <td>65</td>
      <td>0</td>
      <td>Lawson</td>
      <td>Belconnen</td>
      <td>2617</td>
      <td>-35.224992</td>
      <td>149.088179</td>
      <td>4.099591</td>
      <td>1171.296865</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>66</th>
      <td>66</td>
      <td>1</td>
      <td>Lyneham</td>
      <td>North Canberra</td>
      <td>2602</td>
      <td>-35.239801</td>
      <td>149.130735</td>
      <td>2.738301</td>
      <td>1966.819310</td>
      <td>44.0</td>
    </tr>
    <tr>
      <th>67</th>
      <td>67</td>
      <td>2</td>
      <td>Lyons</td>
      <td>Woden Valley</td>
      <td>2606</td>
      <td>-35.340558</td>
      <td>149.073938</td>
      <td>2.096756</td>
      <td>6261.500000</td>
      <td>54.0</td>
    </tr>
    <tr>
      <th>68</th>
      <td>68</td>
      <td>0</td>
      <td>Macarthur</td>
      <td>Tuggeranong</td>
      <td>2904</td>
      <td>-35.405132</td>
      <td>149.131673</td>
      <td>3.992880</td>
      <td>3044.733334</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>69</th>
      <td>69</td>
      <td>0</td>
      <td>Macgregor</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.209774</td>
      <td>149.011021</td>
      <td>3.517380</td>
      <td>686.500000</td>
      <td>15.0</td>
    </tr>
    <tr>
      <th>70</th>
      <td>70</td>
      <td>0</td>
      <td>Macnamara</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.218657</td>
      <td>148.976441</td>
      <td>6.137284</td>
      <td>3044.733334</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>71</th>
      <td>71</td>
      <td>2</td>
      <td>Macquarie</td>
      <td>Belconnen</td>
      <td>2614</td>
      <td>-35.251113</td>
      <td>149.063306</td>
      <td>3.207053</td>
      <td>1499.100084</td>
      <td>68.0</td>
    </tr>
    <tr>
      <th>72</th>
      <td>72</td>
      <td>1</td>
      <td>Mawson</td>
      <td>Woden Valley</td>
      <td>2607</td>
      <td>-35.363368</td>
      <td>149.098894</td>
      <td>1.565181</td>
      <td>6165.000000</td>
      <td>20.0</td>
    </tr>
    <tr>
      <th>73</th>
      <td>73</td>
      <td>0</td>
      <td>McKellar</td>
      <td>Belconnen</td>
      <td>2617</td>
      <td>-35.217463</td>
      <td>149.077032</td>
      <td>3.271774</td>
      <td>1471.116882</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>74</th>
      <td>74</td>
      <td>1</td>
      <td>Melba</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.210074</td>
      <td>149.054127</td>
      <td>2.172843</td>
      <td>703.500000</td>
      <td>19.0</td>
    </tr>
    <tr>
      <th>75</th>
      <td>75</td>
      <td>0</td>
      <td>Mitchell</td>
      <td>Gungahlin</td>
      <td>2911</td>
      <td>-35.218893</td>
      <td>149.136383</td>
      <td>4.597390</td>
      <td>3044.733334</td>
      <td>9.0</td>
    </tr>
    <tr>
      <th>76</th>
      <td>76</td>
      <td>1</td>
      <td>Molonglo</td>
      <td>Molonglo Valley</td>
      <td>0</td>
      <td>-35.299828</td>
      <td>149.040199</td>
      <td>0.833547</td>
      <td>3044.733334</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>77</th>
      <td>77</td>
      <td>1</td>
      <td>Monash</td>
      <td>Tuggeranong</td>
      <td>2904</td>
      <td>-35.415738</td>
      <td>149.090690</td>
      <td>0.597095</td>
      <td>737.000000</td>
      <td>20.0</td>
    </tr>
    <tr>
      <th>78</th>
      <td>78</td>
      <td>1</td>
      <td>Moncrieff</td>
      <td>Gungahlin</td>
      <td>2914</td>
      <td>-35.158821</td>
      <td>149.116306</td>
      <td>2.328109</td>
      <td>699.000000</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>79</th>
      <td>79</td>
      <td>2</td>
      <td>Narrabundah</td>
      <td>South Canberra</td>
      <td>2604</td>
      <td>-35.335692</td>
      <td>149.149222</td>
      <td>2.711774</td>
      <td>11900.000000</td>
      <td>36.0</td>
    </tr>
    <tr>
      <th>80</th>
      <td>80</td>
      <td>1</td>
      <td>Ngunnawal</td>
      <td>Gungahlin</td>
      <td>2913</td>
      <td>-35.172790</td>
      <td>149.111468</td>
      <td>1.298026</td>
      <td>685.500000</td>
      <td>11.0</td>
    </tr>
    <tr>
      <th>81</th>
      <td>81</td>
      <td>1</td>
      <td>Nicholls</td>
      <td>Gungahlin</td>
      <td>2913</td>
      <td>-35.187161</td>
      <td>149.096481</td>
      <td>2.635543</td>
      <td>631.459689</td>
      <td>17.0</td>
    </tr>
    <tr>
      <th>82</th>
      <td>82</td>
      <td>2</td>
      <td>O'Connor</td>
      <td>North Canberra</td>
      <td>2602</td>
      <td>-35.256600</td>
      <td>149.115597</td>
      <td>1.765292</td>
      <td>12800.000000</td>
      <td>36.0</td>
    </tr>
    <tr>
      <th>83</th>
      <td>83</td>
      <td>1</td>
      <td>O'Malley</td>
      <td>Woden Valley</td>
      <td>2606</td>
      <td>-35.351360</td>
      <td>149.110687</td>
      <td>1.518254</td>
      <td>3044.733334</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>84</th>
      <td>84</td>
      <td>1</td>
      <td>Oxley</td>
      <td>Tuggeranong</td>
      <td>2903</td>
      <td>-35.409442</td>
      <td>149.078648</td>
      <td>1.771644</td>
      <td>3044.733334</td>
      <td>37.0</td>
    </tr>
    <tr>
      <th>85</th>
      <td>85</td>
      <td>2</td>
      <td>Page</td>
      <td>Belconnen</td>
      <td>2614</td>
      <td>-35.238547</td>
      <td>149.049940</td>
      <td>1.381300</td>
      <td>1401.158878</td>
      <td>70.0</td>
    </tr>
    <tr>
      <th>86</th>
      <td>86</td>
      <td>1</td>
      <td>Palmerston</td>
      <td>Gungahlin</td>
      <td>2913</td>
      <td>-35.194461</td>
      <td>149.119415</td>
      <td>1.774984</td>
      <td>727.500000</td>
      <td>30.0</td>
    </tr>
    <tr>
      <th>87</th>
      <td>87</td>
      <td>2</td>
      <td>Parkes</td>
      <td>South Canberra</td>
      <td>2600</td>
      <td>-35.295915</td>
      <td>149.135156</td>
      <td>2.279085</td>
      <td>3044.733334</td>
      <td>95.0</td>
    </tr>
    <tr>
      <th>88</th>
      <td>88</td>
      <td>2</td>
      <td>Pearce</td>
      <td>Woden Valley</td>
      <td>2607</td>
      <td>-35.362170</td>
      <td>149.083589</td>
      <td>1.665477</td>
      <td>6105.000000</td>
      <td>40.0</td>
    </tr>
    <tr>
      <th>89</th>
      <td>89</td>
      <td>1</td>
      <td>Phillip</td>
      <td>Woden Valley</td>
      <td>2606</td>
      <td>-35.347044</td>
      <td>149.091009</td>
      <td>0.417048</td>
      <td>3044.733334</td>
      <td>36.0</td>
    </tr>
    <tr>
      <th>90</th>
      <td>90</td>
      <td>2</td>
      <td>Red Hill</td>
      <td>South Canberra</td>
      <td>2603</td>
      <td>-35.333438</td>
      <td>149.120586</td>
      <td>2.152429</td>
      <td>11102.221571</td>
      <td>28.0</td>
    </tr>
    <tr>
      <th>91</th>
      <td>91</td>
      <td>2</td>
      <td>Reid</td>
      <td>North Canberra</td>
      <td>2612</td>
      <td>-35.282598</td>
      <td>149.141221</td>
      <td>2.173201</td>
      <td>3044.733334</td>
      <td>100.0</td>
    </tr>
    <tr>
      <th>92</th>
      <td>92</td>
      <td>1</td>
      <td>Richardson</td>
      <td>Tuggeranong</td>
      <td>2905</td>
      <td>-35.427902</td>
      <td>149.113947</td>
      <td>2.121214</td>
      <td>1241.254869</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>93</th>
      <td>93</td>
      <td>1</td>
      <td>Rivett</td>
      <td>Weston Creek</td>
      <td>2611</td>
      <td>-35.347071</td>
      <td>149.037983</td>
      <td>0.979357</td>
      <td>730.000000</td>
      <td>23.0</td>
    </tr>
    <tr>
      <th>94</th>
      <td>94</td>
      <td>2</td>
      <td>Russell</td>
      <td>North Canberra</td>
      <td>2600</td>
      <td>-35.297960</td>
      <td>149.150279</td>
      <td>2.657789</td>
      <td>3044.733334</td>
      <td>60.0</td>
    </tr>
    <tr>
      <th>95</th>
      <td>95</td>
      <td>1</td>
      <td>Scullin</td>
      <td>Belconnen</td>
      <td>2614</td>
      <td>-35.234534</td>
      <td>149.039072</td>
      <td>0.871915</td>
      <td>1249.250070</td>
      <td>14.0</td>
    </tr>
    <tr>
      <th>96</th>
      <td>96</td>
      <td>0</td>
      <td>Spence</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.198732</td>
      <td>149.064356</td>
      <td>3.728122</td>
      <td>516.770073</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>97</th>
      <td>97</td>
      <td>1</td>
      <td>Stirling</td>
      <td>Weston Creek</td>
      <td>2611</td>
      <td>-35.349584</td>
      <td>149.049358</td>
      <td>0.702434</td>
      <td>3044.733334</td>
      <td>24.0</td>
    </tr>
    <tr>
      <th>98</th>
      <td>98</td>
      <td>0</td>
      <td>Strathnairn</td>
      <td>Belconnen</td>
      <td>2615</td>
      <td>-35.232390</td>
      <td>148.985554</td>
      <td>5.259923</td>
      <td>477.428868</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>99</th>
      <td>99</td>
      <td>0</td>
      <td>Taylor</td>
      <td>Gungahlin</td>
      <td>2913</td>
      <td>-35.146804</td>
      <td>149.107199</td>
      <td>3.867465</td>
      <td>724.500000</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>100</th>
      <td>100</td>
      <td>0</td>
      <td>Theodore</td>
      <td>Tuggeranong</td>
      <td>2905</td>
      <td>-35.449611</td>
      <td>149.119744</td>
      <td>4.048983</td>
      <td>642.500000</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>101</th>
      <td>101</td>
      <td>0</td>
      <td>Throsby</td>
      <td>Gungahlin</td>
      <td>2914</td>
      <td>-35.188954</td>
      <td>149.161749</td>
      <td>3.638973</td>
      <td>713.500000</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>102</th>
      <td>102</td>
      <td>1</td>
      <td>Torrens</td>
      <td>Woden Valley</td>
      <td>2607</td>
      <td>-35.371950</td>
      <td>149.087880</td>
      <td>2.519382</td>
      <td>883.500000</td>
      <td>13.0</td>
    </tr>
    <tr>
      <th>103</th>
      <td>103</td>
      <td>2</td>
      <td>Turner</td>
      <td>North Canberra</td>
      <td>2612</td>
      <td>-35.268870</td>
      <td>149.124577</td>
      <td>0.878674</td>
      <td>3044.733334</td>
      <td>100.0</td>
    </tr>
    <tr>
      <th>104</th>
      <td>104</td>
      <td>1</td>
      <td>Wanniassa</td>
      <td>Tuggeranong</td>
      <td>2903</td>
      <td>-35.397664</td>
      <td>149.090804</td>
      <td>2.595079</td>
      <td>699.000000</td>
      <td>17.0</td>
    </tr>
    <tr>
      <th>105</th>
      <td>105</td>
      <td>1</td>
      <td>Waramanga</td>
      <td>Weston Creek</td>
      <td>2611</td>
      <td>-35.352815</td>
      <td>149.062215</td>
      <td>1.675379</td>
      <td>757.500000</td>
      <td>25.0</td>
    </tr>
    <tr>
      <th>106</th>
      <td>106</td>
      <td>0</td>
      <td>Watson</td>
      <td>North Canberra</td>
      <td>2602</td>
      <td>-35.234823</td>
      <td>149.159446</td>
      <td>4.095278</td>
      <td>5567.500000</td>
      <td>15.0</td>
    </tr>
    <tr>
      <th>107</th>
      <td>107</td>
      <td>2</td>
      <td>Weetangera</td>
      <td>Belconnen</td>
      <td>2614</td>
      <td>-35.250114</td>
      <td>149.049737</td>
      <td>2.591961</td>
      <td>6934.720981</td>
      <td>71.0</td>
    </tr>
    <tr>
      <th>108</th>
      <td>108</td>
      <td>1</td>
      <td>Weston</td>
      <td>Weston Creek</td>
      <td>2611</td>
      <td>-35.332488</td>
      <td>149.058736</td>
      <td>1.567158</td>
      <td>838.000000</td>
      <td>22.0</td>
    </tr>
    <tr>
      <th>109</th>
      <td>109</td>
      <td>0</td>
      <td>Whitlam</td>
      <td>Molonglo Valley</td>
      <td>0</td>
      <td>-35.278096</td>
      <td>149.036398</td>
      <td>2.943000</td>
      <td>3044.733334</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>110</th>
      <td>110</td>
      <td>1</td>
      <td>Wright</td>
      <td>Molonglo Valley</td>
      <td>2611</td>
      <td>-35.319264</td>
      <td>149.033617</td>
      <td>1.652823</td>
      <td>783.000000</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>111</th>
      <td>111</td>
      <td>2</td>
      <td>Yarralumla</td>
      <td>South Canberra</td>
      <td>2600</td>
      <td>-35.304041</td>
      <td>149.098635</td>
      <td>3.256987</td>
      <td>15775.000000</td>
      <td>21.0</td>
    </tr>
  </tbody>
</table>
</div>
#+end_export

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
df_cluster['Cluster'].value_counts()
#+END_SRC

#+results:
: 1    44
: 0    41
: 2    27
: Name: Cluster, dtype: int64

*** Revisit statistics on clustered suburbs
    :PROPERTIES:
    :CUSTOM_ID: revisit-statistics-on-clustered-suburbs
    :END:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none :file figures/suburbs_statistics_clusters.jpg
boxprops = dict(linestyle='-', linewidth=4, color='k')
medianprops = dict(linestyle='-', linewidth=4, color='k')

fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(24, 6))

bp1 = df_cluster.boxplot(column='Median Price',by='Cluster', ax=ax1,
                    showfliers=True, showmeans=True,
                    boxprops=boxprops, medianprops=medianprops,
                    return_type='dict')

bp2 = df_cluster.boxplot(column='venue count',by='Cluster', ax=ax2,
                    showfliers=True, showmeans=True,
                    boxprops=boxprops, medianprops=medianprops,
                    return_type='dict')

bp3 = df_cluster.boxplot(column='Nearest',by='Cluster', ax=ax3,
                    showfliers=True, showmeans=True,
                    boxprops=boxprops, medianprops=medianprops,
                    return_type='dict')

# boxplot style adjustments
adjust_boxplot_style(bp1)
adjust_boxplot_style(bp2)
adjust_boxplot_style(bp3)

# get rid of "boxplot grouped by" title
plt.suptitle("")

# label adjustment
ax1.set_title("Median price for suburbs \nin different towncenters", fontsize=20)
ax1.set_ylabel('Median Price (K)', fontsize=20)
ax1.set_xlabel('')
ax1.tick_params(axis='y', labelsize=20)
ax1.tick_params(axis='x', labelsize=20)
ax1.tick_params(axis="x", rotation=45)

ax2.set_title("Venue count for suburbs \nin different towncenters", fontsize=20)
ax2.set_ylabel('Venue numbers', fontsize=20)
ax2.set_xlabel('')
ax2.tick_params(axis='y', labelsize=20)
ax2.tick_params(axis='x', labelsize=20)
ax2.tick_params(axis="x", rotation=45)

ax3.set_title("Distance to nearest townceters for suburbs \nin different towncenters", fontsize=20)
ax3.set_ylabel('Distance (km)', fontsize=20)
ax3.set_xlabel('')
ax3.tick_params(axis='y', labelsize=20)
ax3.tick_params(axis='x', labelsize=20)
ax3.tick_params(axis="x", rotation=45)
#+END_SRC

#+results:
[[file:figures/suburbs_statistics_clusters.jpg]]


Now let's create a Folium map and add the clusterd suburbs together with
towncenters. It is clear that suburbs in North and South Canberra have
been segmented into one category as these suburnbs. The other category
are those very close to towncenters while the rest suburbs make up the
last category.

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# create map
map_clusters = folium.Map(location=[latitude, longitude], zoom_start=11)

# set color scheme for the clusters
x = np.arange(kclusters)
ys = [i + x + (i*x)**2 for i in range(kclusters)]
colors_array = cm.rainbow(np.linspace(0, 1, len(ys)))
rainbow = [colors.rgb2hex(i) for i in colors_array]

# add markers to the map
markers_colors = []
for lat, lon, poi, cluster in zip(df_cluster['Latitude'], df_cluster['Longitude'], df_cluster['Suburb'], df_cluster['Cluster']):
    label = folium.Popup(str(poi) + ' Cluster ' + str(cluster), parse_html=True)
    folium.CircleMarker(
        [lat, lon],
        radius=5,
        popup=label,
        color=rainbow[cluster-1],
        fill=True,
        fill_color=rainbow[cluster-1],
        fill_opacity=0.7).add_to(map_clusters)
    
# add markers to towncenters
for lat, lng, towncenter in zip(df_town['Latitude'], df_town['Longitude'], df_town['Towncenter']):
    label = '{}'.format(towncenter)
    label = folium.Popup(label, parse_html=True)
    folium.CircleMarker(
        [lat, lng],
        radius=30,
        popup=label,
        color='purple',
        fill=True,
        fill_color='#EDE3FF',
        fill_opacity=0.3,
        parse_html=False).add_to(map_clusters)
       
map_clusters
#+END_SRC

** k-means clustering on venue category dataset
   :PROPERTIES:
   :CUSTOM_ID: k-means-clustering-on-venue-category-dataset
   :END:

Let use k-means to cluster the suburbs based on the venue category
information in each suburb now. First find optimal number of cluster:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# canberra_venues = pd.read_csv('data/canberra_venues.csv')
canberra_venues.head()

# one hot encoding
canberra_onehot = pd.get_dummies(canberra_venues[['Venue Category']], prefix="", prefix_sep="")

# add suburb column back to dataframe
canberra_onehot['Suburb'] = canberra_venues['Suburb'] 

# move Suburb column to the first column
list_column = canberra_onehot.columns.tolist()
number_column = int(list_column.index('Suburb'))
list_column = [list_column[number_column]] + list_column[:number_column] + list_column[number_column+1:] 
canberra_onehot = canberra_onehot[list_column]

canberra_onehot.head()
#+END_SRC

Now let's group rows by suburb and by taking the mean of the frequency
of occurrence of each category:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
canberra_grouped = canberra_onehot.groupby('Suburb').mean().reset_index()
canberra_grouped.head()
#+END_SRC

Run through different k values:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
canberra_grouped_clustering = canberra_grouped.drop('Suburb', 1)

distortions = []
K = range(1,10)
for k in K:
    kmeanModel = KMeans(n_clusters=k, random_state=0).fit(canberra_grouped_clustering)
    distortions.append(sum(np.min(cdist(canberra_grouped_clustering, kmeanModel.cluster_centers_, 'canberra'), axis=1)) / canberra_grouped_clustering.shape[0])

#There are different metric distance function for spatial distance. 
#I choose correlation instaed of euclidean because the canberra function gives me more clear view of elbow break point.

# Plot the elbow
plt.plot(K, distortions, 'bx-')
plt.xlabel('k')
plt.ylabel('Distortion')
plt.title('The Elbow Method showing the optimal k')
plt.show()
#+END_SRC


Use optimal number 4 to rerun the k-means clustering:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# set number of clusters
kclusters = 4

# run k-means clustering
kmeans = KMeans(n_clusters=kclusters, random_state=0).fit(canberra_grouped_clustering)

# check cluster labels generated for each row in the dataframe
labels = kmeans.labels_
df_venues['Cluster'] = labels
df_venues.head()
#+END_SRC

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
df_venues_merged = pd.merge(df_can, df_venues, left_on='Suburb', right_on='Suburb', how='inner')
df_venues_merged.head()
#+END_SRC

Now let's create a Folium map and use cluster labels from venue
categories:

#+BEGIN_SRC jupyter-python :session py3 :async yes :exports none
# create map
map_clusters = folium.Map(location=[latitude, longitude], zoom_start=11)

# set color scheme for the clusters
x = np.arange(kclusters)
ys = [i + x + (i*x)**2 for i in range(kclusters)]
colors_array = cm.rainbow(np.linspace(0, 1, len(ys)))
rainbow = [colors.rgb2hex(i) for i in colors_array]

# add markers to the map
markers_colors = []
for lat, lon, poi, cluster in zip(df_venues_merged['Latitude'], df_venues_merged['Longitude'], df_venues_merged['Suburb'], df_venues_merged['Cluster']):
    label = folium.Popup(str(poi) + ' Cluster ' + str(cluster), parse_html=True)
    folium.CircleMarker(
        [lat, lon],
        radius=5,
        popup=label,
        color=rainbow[cluster-1],
        fill=True,
        fill_color=rainbow[cluster-1],
        fill_opacity=0.7).add_to(map_clusters)
    
# add markers to towncenters
for lat, lng, towncenter in zip(df_town['Latitude'], df_town['Longitude'], df_town['Towncenter']):
    label = '{}'.format(towncenter)
    label = folium.Popup(label, parse_html=True)
    folium.CircleMarker(
        [lat, lng],
        radius=30,
        popup=label,
        color='purple',
        fill=True,
        fill_color='#EDE3FF',
        fill_opacity=0.3,
        parse_html=False).add_to(map_clusters)
       
map_clusters
#+END_SRC

* Results and Discussion
  :PROPERTIES:
  :CUSTOM_ID: results-and-discussion-
  :END:

Using the main dataset, most cluster 1 suburbs are located at the inner
north or south Canberra. While these suburbs are well established with
various venues, their price are also much higher than other suburbs.
Suburbs in cluster 2 have the lowest price, but meanwhile they also do
not have as many venues and the travel distance to towncenters are
higher. Cluster 0 suburbs seem to have the best balance for all three
factors and not superisingly they are located around other towncenters
apart from the North and South Canberra.

Clustering results using venue category information are even more
interesting: suburbs in North and South Canberra (together with
Tuggeranoon) again are clustered into one segment while suburbs in other
north towns (Belconnen and Gungahlin) are segmented together. Suburbs in
Woden and Westen Creek share some similarities unlike other towns. These
difference might very well becasue of the developmnet shift from South
Canberra to North Canberras. Due to the scope of the study, I will not
furth explore the behind reasons.

Based on the above analysis, hopefully our young family now have
more information to refere to when they finnaly decide which suburb to
settle in.

* Conclusion
  :PROPERTIES:
  :CUSTOM_ID: conclusion-
  :END:

In this study, various techniques varing from webscraping to open
dataset have been used to collect data related to Canberra suburbs.
Unsupervised k-means clustering algorithms have been applied to two
assembed datasets: one master dataset consisting of median house price,
number of venues and closest distance to nearby towncenters; while the
second dataset includes venue category information around each suburb.

As per the decision to choose which suburb to live in, certainly more
factors should be considered, e.g. local schools, developing trend. They
are not included in this study due to the limited time and the already
lengthy contet, but definitely will be helpful to provide an even
accurate and detailed suburb segmentation.

Source of this capstone project
[[https://github.com/fanpeng-kong/Coursera_Capstone][can be found on my
Github]].
